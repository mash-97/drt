#!/usr/bin/env ruby

require 'thor'
require 'colored'

require 'drt'


unless Dir.exist?(::DRT::DRT_DIRPATH)
  Dir.mkdir(::DRT::DRT_DIRPATH)
end

CONFIG = ::DRT::Config.new(::DRT::DRT_CONFIGPATH, ::DRT::DEFAULT_DB_PATH, ::DRT::DEFAULT_DB_LOG_PATH)
DRT_OBJ = ::DRT::DRT.new(CONFIG)

class DRTThor < Thor

  desc 'version', 'show version'
  def version
    say("drt (#{::DRT::VERSION})".bold.green)
  end
  
  desc 'update [--student_ids, --semester_ids]', 'update DB with semester results of students'
  option :student_ids, type: :array
  option :semester_ids, type: :array
  def update
    student_ids = options[:student_ids] or ::DRT::Student.distinct(:student_id).select(:student_id).collect do |x|
      x.student_id
    end
    semester_ids = options[:semester_ids] or ::DRT::SemesterResult.distinct(:semester_id).select(:semester_id).collect do |x|
      x.semester_id
    end

    DRT_OBJ.swing_db_for_semester_result(student_ids: student_ids, semester_ids: semester_ids)
  end

  desc 'detect_range [--semester_code, --dept_code, --start_id, --end_id]', 'detect range for valid student ids'
  option :semester_code, type: :string
  option :dept_code, type: :string
  option :start_id, type: :numeric
  option :end_id, type: :numeric
  
  def detect_range
    semester_code = options[:semester_code]
    dept_code = options[:dept_code]
    start_id = options[:start_id].to_i
    end_id = options[:end_id].to_i
    primary_range = (start_id..end_id)

    result = DRT_OBJ.detect_ranges(semester_code, dept_code, primary_range)
    say("Range Founds: #{result.to_s}".bold)
  end

  desc 'detect_ids DEPARTMENT_CODE [--semester_codes, --start_id|0, --end_id|7000]', 'detect valid student ids with their info'
  option :semester_codes, type: :array, default: []
  option :start_id, type: :string, default: "0"
  option :end_id, type: :string, default: "7000"
  def detect_ids(department_code)
    department_code = department_code.to_s
    semester_codes = options[:semester_codes]
    if semester_codes.length == 0 then
      # generate semester codes from 151..current_date_year_semester
      semester_codes = (14..Time.now.year.to_s[2..].to_i).collect(&:to_s).collect{|x| (1..3).collect{|i| x+i.to_s}}.flatten
      say("Semester codes: #{semester_codes.to_s}".bold)
    end
    semester_codes.collect!(&:to_s)
    start_id = options[:start_id].to_i
    end_id = options[:end_id].to_i
    id_ranges = DRTThor.idperms(start_id..end_id)
    
    log_file_path = File.join(File.absolute_path(Dir.pwd), "#{department_code}__#{Time.now.strftime('%d_%m_%Y__%H_%M_%S')}.log")
    logger = ::DRT::LOGGER_GEN.call(log_file_path)

    student_id_log_file_path = File.join(File.absolute_path(Dir.pwd), "student_ids__#{department_code}__#{Time.now.strftime('%d_%m_%Y__%H_%M_%S')}.log")
    student_id_logger = ::DRT::LOGGER_GEN.call(student_id_log_file_path)
    
    logger.info("semester codes: #{semester_codes.to_s}")
    logger.info("total_semester_codes: #{semester_codes.length}")
    logger.info("id range: #{id_ranges.min} .. #{id_ranges.max}")

    total_valid_student_ids = 0
    invalid_tries = 0

    semester_code_cycle = semester_codes.cycle
    current_semester_code = semester_code_cycle.next
    id_ranges.each do |post_id|
      student_id = [current_semester_code, department_code, post_id].join('-')
      student_info = try_student_info(student_id, logger)
      
      if not student_info then
        invalid_tries += 1
        say("==> #{student_id} nil".yellow.bold)
        previous_semester_code = current_semester_code
        current_semester_code = semester_code_cycle.next 
        while(current_semester_code!=previous_semester_code) do
          student_id = [current_semester_code, department_code, post_id].join('-')
          student_info = try_student_info(student_id, logger)
          if student_info 
            logger.info("csc: #{current_semester_code} for #{department_code}-#{post_id}")
            say("==> csc: #{current_semester_code} for #{department_code}-#{post_id}".yellow.bold)
            break
          end
          say("==> #{student_id} nil".yellow.bold)
          current_semester_code = semester_code_cycle.next
          invalid_tries += 1
        end
        logger.info("cycled semester code: #{current_semester_code} for #{department_code}-#{post_id}")
        say("==> cycled semester code: #{current_semester_code} for #{department_code}-#{post_id}".yellow.bold)
      end
      if student_info then
        total_valid_student_ids += 1
        say("==> #{student_id} found!".green.bold)
        student_id_logger.info("#{student_id}: #{student_info}")
        logger.info("valid id: #{student_id}")
        
      end
    end
    logger.info("total valid ids: #{total_valid_student_ids}")
    logger.info("total invalid tries: #{invalid_tries}")
    say("total valid ids: #{total_valid_student_ids}".green.bold)
    say("total invalid tries: #{invalid_tries}".yellow.bold)
  end

  desc 'brute_detect_ids DEPARTMENT_CODE [--semester_codes, --start_id|0, --end_id|7000]', 'detect valid student ids with their info'
  option :semester_codes, type: :array, default: []
  option :start_id, type: :string, default: "0"
  option :end_id, type: :string, default: "7000"
  def brute_detect_ids(department_code)
    department_code = department_code.to_s
    semester_codes = options[:semester_codes]
    if semester_codes.length == 0 then
      # generate semester codes from 151..current_date_year_semester
      semester_codes = (14..Time.now.year.to_s[2..].to_i).collect(&:to_s).collect{|x| (1..3).collect{|i| x+i.to_s}}.flatten
      say("Semester codes: #{semester_codes.to_s}".bold)
    end
    semester_codes.collect!(&:to_s)
    start_id = options[:start_id].to_i
    end_id = options[:end_id].to_i
    id_ranges = DRTThor.idperms(start_id..end_id)
    
    log_file_path = File.join(File.absolute_path(Dir.pwd), "#{department_code}__#{Time.now.strftime('%d_%m_%Y__%H_%M_%S')}.log")
    logger = ::DRT::LOGGER_GEN.call(log_file_path)

    student_id_log_file_path = File.join(File.absolute_path(Dir.pwd), "student_ids__#{department_code}__#{Time.now.strftime('%d_%m_%Y__%H_%M_%S')}.log")
    student_id_logger = ::DRT::LOGGER_GEN.call(student_id_log_file_path)
    
    logger.info("semester codes: #{semester_codes.to_s}")
    logger.info("total_semester_codes: #{semester_codes.length}")
    logger.info("id range: #{id_ranges.min} .. #{id_ranges.max}")

    total_valid_student_ids = 0
    invalid_tries = 0

    id_ranges.each do |post_id|
      semester_codes.each do |semester_code|
        student_id = [semester_code, department_code, post_id].join('-')
        student_info = try_student_info(student_id, logger)
        
        if not student_info then
          invalid_tries += 1
          say("==> #{student_id} nil".blue.bold)
          logger.info("invalid id: #{student_id}")
        end
        if student_info then
          total_valid_student_ids += 1
          say("==> #{student_id} found!".green.bold)
          student_id_logger.info("#{student_id}: #{student_info}")
          logger.info("valid id: #{student_id}")
        end
      end
    end
    logger.info("total valid ids: #{total_valid_student_ids}")
    logger.info("total invalid tries: #{invalid_tries}")
    say("total valid ids: #{total_valid_student_ids}".green.bold)
    say("total invalid tries: #{invalid_tries}".yellow.bold)
  end

  def try_student_info(student_id, logger, tries=1000, sleep=5)
    student_info = nil
    tries.times do |i|
      begin
        student_info = ::DRT.get_student_info(student_id)
      rescue Faraday::ConnectionFailed => e
        say("##[tries: #{i+1}]##> Connection Error! #{e}".red.bold)
        sleep(sleep)
        continue
      end
      break
    end
    return student_info
  end

  desc 'id_roller [--semester_code, --dept_code, --start_id, --end_id, --tries|3, --sleep|2]', 'detect range for valid student ids'
  option :semester_code, type: :string
  option :dept_code, type: :string
  option :start_id, type: :numeric
  option :end_id, type: :numeric
  option :tries, type: :numeric, default: 3
  option :sleep_time, type: :numeric, default: 2
  def id_roller
    semester_code = options[:semester_code]
    dept_code = options[:dept_code]
    start_id = options[:start_id].to_i
    end_id = options[:end_id].to_i
    primary_range = (start_id..end_id)

    log_file_path = File.join(File.absolute_path(Dir.pwd), "id_roller__#{Time.now.strftime('%d_%m_%Y__%H_%M_%S')}.log")
    student_id_log_file_path = File.join(File.absolute_path(Dir.pwd), "#{semester_code}_#{dept_code}__#{Time.now.strftime('%d_%m_%Y__%H_%M_%S')}.log")
    logger = ::DRT::LOGGER_GEN.call(log_file_path)
    student_id_logger = ::DRT::LOGGER_GEN.call(student_id_log_file_path)

    logger.info("DETECT ID RANGES GIVEN SEMESTER_CODE DEPARTMENT_CODE AND POST_ID RANGE")
    logger.info("SEMESTER_CODE(#{semester_code}) DEPARTMENT_CODE(#{dept_code}) POST_ID RANGE(#{start_id}..#{end_id})")

    say("SEMESTER_CODE(#{semester_code}) DEPARTMENT_CODE(#{dept_code}) POST_ID RANGE(#{start_id}..#{end_id})".blue.bold)

    valid_ranges = []
    fp = nil
    pp = nil
    primary_range.each do |post_id|
      student_id = [semester_code, dept_code, post_id].map(&:to_s).join('-')
      student_info = nil
      options[:tries].times do |i|
        begin
          student_info = ::DRT.get_student_info(student_id)
        rescue Faraday::ConnectionFailed => e
          say("##[tries: #{i+1}]##> Connection Error! #{e}".red.bold)
          sleep(options[:sleep_time])
          continue
        end
        break
      end
      if student_info != nil
        say("#{student_id}".bold+":"+'found'.green.bold)
        student_id_logger.info("#{student_id}: #{student_info.select{|k,v| [:student_name, :campus_name, :shift].include?(k)}}")

        if pp == nil then
          fp = post_id
        end
        pp = post_id
      else
        say("#{student_id}".bold+":"+'not found'.yellow.bold)
        if fp != nil and pp != nil then
          valid_ranges << (fp..pp)
          say("==> Valid range: #{(fp..pp).to_s}")
          logger.info("Valid range: #{(fp..pp).to_s}")
          fp = nil
        end
        pp = nil
      end
    end
    if fp != nil and pp != nil then
      valid_ranges << (fp..pp)
      say("==> Valid range: #{(fp..pp).to_s}")
      logger.info("Valid range: #{(fp..pp).to_s}")
    end
    
    logger.info("Valid Ranges: #{valid_ranges.to_s}")

    say("===> Basic Logs at: #{log_file_path}".green.bold)
    say("===> Student ID Logs at: #{student_id_log_file_path}".green.bold)
  end

  desc 'mass_update [--start_student_id, --end_student_id, --start_year, --end_year, --sem]',
       'mass update DB with semester results of students ranged year'
  option :start_student_id, type: :string
  option :end_student_id, type: :string
  option :start_year, type: :numeric
  option :end_year, type: :numeric
  option :sem, type: :numeric, default: 3
  def mass_update
    sem = options[:sem]
    ssi = options[:start_student_id].split('-')
    esi = options[:end_student_id].split('-')
    ssii = ssi[2].to_i
    esii = esi[2].to_i
    diff = esii - ssii

    start_year = options[:start_year]
    end_year = options[:end_year]
    diffy = end_year - start_year

    if diff < 0 || diffy < 0 || !(ssi[0] == esi[0] && ssi[1] == esi[1])
      say('Check arguments'.red)
      return
    end

    say("Diff exceeds #{diff}, #{diffy}".yellow) if diff > 100 || diffy > 3

    student_ids = (ssii..esii).collect { |x| [*ssi[0..1], x.to_s].join('-') }
    semester_ids = (start_year..end_year).collect do |x|
      sem.times.collect { |i| (x % 100).to_s + (i + 1).to_s }
    end
    semester_ids.flatten!
    t, n = DRT_OBJ.swing_db_for_semester_result(student_ids: student_ids, semester_ids: semester_ids)
    say("\n\n==> Total Updates: #{t} -- Total Not Found: #{n}".blue.bold)
  end

  # return all possible ids
  def self.idperms(id_range=(0..7000))
    id_perms = []
    max_step_lim = id_range.max.to_s.length
    max_step_lim.times do |perm_length|
      perm_length += 1
      id_perms.concat (0..9).collect(&:to_s).repeated_permutation(perm_length).collect(&:join)
    end
    id_perms = id_perms.select{|x| id_range.include?(x.to_i)}
    return id_perms
  end

end

# if $0 == __FILE__ then
#   puts(DRTThor.idperms(0..1555))
#   gets 
# end
DRTThor.start(ARGV)

